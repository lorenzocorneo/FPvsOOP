\documentclass{article}

\usepackage{natbib}
\usepackage{url}
\usepackage{graphicx}

\graphicspath{ {img/} }
\begin{document}

\title{Functional vs. Object Oriented Programming: Productivity comparison}
\author{Lorenzo Corneo and Nikolaos-Ektoras Anestos \\
	\{corneo, anestos\}@kth.se}
\date{\today}
\maketitle

\begin{abstract}
Human resources and time consumption are very important factors in software development. Both developers and managers try to maximise their productivity, in order to increase as much as possible the profits or gain market advantage. We assume that choosing an appropriate programming paradigm is a critical factor that leads to a better allocation of human resources.

The main object of investigation in this project are the lines of code needed to develop two different implementations of the same program and the level of reusability of existing code.

Functional programming has some fundamental benefits that increase programmer productivity over that when OOP languages. The purpose of this project is to demonstrate some of the benefits of functional programming over OOP, in order to persuade developers to switch to functional programming.

From the evaluation of the gathered data it is possible to see that, averagely, the number of Lines Of Code in a functional programming language is smaller than in an Object Oriented Programming language. As a consequence, Functional Programming allows an increased productivity (fewer lines of code correspond to a time saving during development).
\end{abstract}

\smallskip
\noindent \textbf{Keywords.} Functional Programming, Object Oriented Programming, Comparison, Productivity, Code Reuse.

\section{Introduction}

The paper presents the results of a quantitative evaluation of code implemented in both Functional Programming and Object Oriented Programming. The main parameters that will be analysed are the Line Of Code and the Code Reuse.

The main test-bed for the productivity analysis is based on the LOC of different implementations (both FP and OOP) of very well-known algorithms. The language pool is composed by Erlang, Haskell, Scala, F\#, for the FP languages and by Java, C++, C\#, Python for the OOP languages.

The CR is evaluated counting the difference in terms of LOC between adjacent releases of a program. Object of the investigation, as a case study, is the asynchronous web server Play framework\cite{play}, that is implemented both in Java and Scala.

In section 2, a summary of the studied literature will be presented while in section 3 the methods and the hypothesis will be discussed. The results of the investigation and the analysis are presented in section 5, in section 6 a discussion about the problems and additional work is provided.

The aim of the research is to show the benefits of FP over OOP with the hope to persuade software developer to adopt FP as their main programming paradigm, for a better productivity and code reuse. 

\section{Literature study}

OOP is the de facto standard programming paradigm for companies and widely adopted all around the world. This find a confirmation in the TIOBE Index\cite{tiobe}. In fact, in the first positions only OOP and Web programming languages are found, while the first FP language is Scala at the 24th position with a very low rating of 0.781\%.

Nevertheless, functional programming gurus always try to persuade imperative programmers to switch to this paradigm promising incredible advantages. Amongst these benefits we found the lack of assignment statements (variables never change) and side effects, which is the major source of bugs in software development\cite{fpmatter}.

Furthermore, a thorough evaluation about the two programming paradigms has been performed by Harrison\cite{harrison}. He defined parameters to be able to measure the quality of the software, including LOC and CR. Then, from the domain application of the image processing, he selected a developer with similar skills both in C++ and SML (functional language of the ML family) who developed a set of 12 algorithms in both languages. From the analysis of the results, it turned out that there are not many differences between the two paradigms.

Nonetheless, FP finds very important benefits in the application domain of the prototypes where a case study project is implemented in Haskell in 85 LOC against the 1105 of C++\cite{Haskell-vs-ada}. This is due to three main factors: (a) the syntax is simpler, (b) the use of higher order functions and (c) the standard list-manipulation primitives (i.e. map, fold, zip, ...).

\section{Hypothesis}

Human resources and time consumption are very important factors in software development, especially for companies that want to optimise profits and gain advantages from the market. 

We strongly believe that, using functional programming languages, developers will be more productive and they will also produce higher quality code that will allow them to reuse much of it when releasing newer versions of their programs.

\section{Methods}

A quantitative method is used for this project because the authors have gathered data from many sources and they report in this paper. Afterward, the analysis of the gathered data is performed so that the initial hypothesis will be either accepted or rejected.

The approach used is deductive because we started this research with our own hypothesis on the basis of existing theories, for instance, regarding the benefits of FP and the advantages that developers can gain in software production.

Afterward, when the data has been acquired, the authors perform observation and analysis of the gotten results. From that, it will be possible to accept or reject the initial hypothesis.

Static code analysis on the set of algorithms described below has been performed using the command line tool called Count Lines of Code (cloc) \cite{cloc}, which counts lines of code, blank lines and comments in multiple languages. There are several options on how to present the data using this tool, i.e. one can obtain an analysis of a language used inside a project (several files), or extract results for each file individuals etc.

\section{Results and Analysis}

The experimentation consists in static code analysis on a set of eight algorithms\cite{algorithms}, namely:

\begin{itemize}
\item FASTA, generate and write random DNA sequences.
\item k-nucleotide, repeatedly update hashtables and k-nucleotide strings.
\item Mandelbrot, generate a Mandelbrot set and write a portable bitmap.
\item n-body, perform an N-body simulation of the Jovian planets.
\item pi-digits, calculate the digits of Pi with arbitrary-precision arithmetic.
\item regex-dna, match DNA 8-mers and substitute nucleotides for IUB code.
\item reverse-complement, read DNA sequences and write their reverse-complement.
\item spectral-norm, calculate an eigenvalue using the power method.
\end{itemize}

This set of algorithms has been implemented in Haskell, Erlang, Scala, Clojure, F\# and Python for the functional programming paradigm, in C++, C\#, Go and Java for the object-oriented paradigm.

\subsection{Lines of Code}

In the experimentation we analysed the LOC for each language per each algorithm and the results are shown in Table \ref{tab:all}. In Fig. \ref{fig:alg} is possible to see which language is the most efficient in terms of lines of code per each single algorithm.

An alternative way to visualise these results is to think in terms of language and display which algorithms is the best to implement in and to be more productive. Fig \ref{fig:lang} shows this alternative representation.

\begin{figure}[h]
\includegraphics[width=\textwidth]{2}
\caption{The graph shows the distribution of the LOC of different languages implementation for different algorithms.}
\label{fig:alg}
\end{figure}

\begin{table}[htbp]
\centering
\caption{LOC for different implementations.}
\label{tab:all}
    \begin{tabular}{rcccccccccc}

         & Haskell & Erlang & Scala & Clojure & F\#  & Python & C++ & C\#  & Go  & Java \\ 
\hline
        FASTA                & 111     & 61     & 91    & 129     & 69  & 84     & 132 & 144 & 162 & 292  \\ 
        k-nucleotide         & 159     & 67     & 194   & 266     & 104 & 156    & 117 & 168 & 175 & 143  \\ 
        Mandelbrot           & 49      & 42     & 59    & 110     & 54  & 59     & 79  & 63  & 103 & 55   \\ 
        n-body               & 166     & 114    & 117   & 189     & 98  & 89     & 132 & 100 & 127 & 138  \\ 
        Pi-digit             & 13      & 33     & 88    & 266     & 89  & 33     & 72  & 113 & 85  & 110  \\ 
        regex-dna            & 106     & 95     & 148   & 51      & 52  & 38     & 62  & 38  & 77  & 148  \\ 
        reverse-compl.   & 68      & 136    & 66    & 64      & -   & 61     & 222 & 85  & 174 & 182  \\ 
        spectral-norm        & 22      & 35     & 50    & 94      & 59  & 39     & 161 & 109 & 72  & 98  \\
\hline
    \end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\caption{LOC for the two paradigms.}
\label{tab:fpvsoop}
    \begin{tabular}{rcccccccccc}

         & FP & OOP \\ 
\hline
        FASTA  & 91 & 183 \\ 
        k-nucleotide & 158 & 151\\ 
        Mandelbrot & 63 & 75 \\ 
        n-body & 129 & 125 \\ 
        Pi-digit & 87 & 95 \\
        regex-dna & 82 & 65 \\ 
        reverse-compl. & 66 & 166 \\ 
        spectral-norm & 50 & 110 \\
\hline
    \end{tabular}
\end{table}

\begin{figure}[h]
\includegraphics[width=\textwidth]{3}
\caption{The graph shows the LOC used to solve each algorithm for the same language.}
\label{fig:lang}
\end{figure}

Table \ref{tab:all} contains many measurements and it is not immediate to understand its meaning. Table \ref{tab:fpvsoop} summarise the aforementioned results in terms of FP and OOP, where the average of the LOC are the entries of the table for the two paradigms, and Fig. \ref{fig:fpvsoop} is the graphical equivalent representation.

\begin{figure}[h]
\includegraphics[width=\textwidth]{1}
\caption{The graph represents the distribution of both FP and OOP paradigm in different algorithms.}
\label{fig:fpvsoop}
\end{figure}

What we evince from the gathered data is that, normally, there is no big difference between the LOC for FP and OOP. Nevertheless, in algorithms like FASTA, revers-complement and spectral-norm, the LOC in FP implementations are less than the half of OOP implementation. This find explanation in \cite{fpmatter} where the benefits of FP are discussed. Among the most significative there are: the syntax (which is simpler), higher order functions and the standard list-manipulation primitives (which offer better abstraction and code reuse).

\subsection{Code Reuse}

It has not been possible to succeed in the experimentation concerning the CR as we could not find a suitable case study\cite{play, flink, rx}. For instance, many implementations are based on the JVM so that the developers reuse their Java implementation building an API layer for functional languages, like Scala and Clojure.

\section{Discussion}

Static code analysis on the lines of code itself is not enough to have a global vision about the two paradigms. In fact, there are many additional factors that affect productivity such as the documentation, the comments, the development time, the application domain, the experience of the developer, the time to implement modifications\cite{harrison, Haskell-vs-ada}.

Nevertheless, we strongly believe that the LOC are directly involved in the productivity and our hypothesis finds confirmation in \cite{Haskell-vs-ada}. In fact, in Fig. \ref{fig:hudak} we notice that in (1), (2), (3), (10) the development time is proportional to the LOC and this fact support our hypothesis.

\begin{figure}[h]
\includegraphics[width=\textwidth]{4}
\caption{The result of Hudak and Jones experimentation in\cite{Haskell-vs-ada}.}
\label{fig:hudak}
\end{figure}

\section{Conclusion}

In this investigation we wanted to see whether the functional programming paradigm would affect positively the productivity and the code reuse during the software development process. 

Unfortunately, we were not able to check whether it is easier for functional programmers to upgrade software in new releases due to difficulties in finding an appropriate case study. In fact, many framework has been taken as case study but in none of them we could find a parallel branch. Usually, these framework has been early developed in Java and thanks to the JVM they could reuse the already existing Java code for feeding an API layer in other JVM-based functional languages.

We were able to correlate the productivity through the analysis of the LOC and the development time. After the evaluation we can state that FP has real advantages over OOP as it is usually less verbose and this implies time saving.

Even though we could not demonstrate benefits in CR, our findings suggest that the functional programming paradigm might really help developers in terms of productivity in order to improve the allocation of human resources.

\bibliography{article}
\bibliographystyle{plain}

%\begin{thebibliography}{9}
%\bibitem{tiobe}
%http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
%\bibitem{flink}
%Apache Flink. 2015. Apache Flink: Scalable Batch and Stream Data Processing. [ONLINE] Available at: http://flink.apache.org. [Accessed 16 September 15].
%\bibitem{rx}
%ReactiveX. 2015. ReactiveX. [ONLINE] Available at: http://reactivex.io/. [Accessed 16 September 15].
%\bibitem{fpoop}
%R. Harrison, \enquote*{Comparing programming paradigms: an evaluation of functional and object-oriented programs}, Jul. 1996 [Online]. Available: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=\&arnumber=511273
%\bibitem{githubapi}
%GitHub Developer. 2015. Statistics | GitHub API. [ONLINE] Available at: https://developer.github.com/v3/repos/statistics/. [Accessed 16 September 15].
%\bibitem{benkio}
%https://github.com/benkio/ITC-Slides
%\end{thebibliography}

\end{document}